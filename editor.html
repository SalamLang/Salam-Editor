<style>
	* {
		padding: 0;
		margin: 0;
	}

	.editor {
		direction: rtl;
		text-align: right;
		width: 100%;
		height: 100vh;
		display: flex;
		flex-direction: row;
		line-height: 1.5;
		font-size: 1.5rem;
		font-family: sans-serif;
	}

	.editor-lines {
		width: auto;
		min-width: 20px;
		background-color: #f5f5f5;
		color: #6c6c6c;
		border-right: 1px solid #ddd;
		list-style: none;
		overflow: hidden;
		height: 100%;
		padding-right: 10px;
		padding-left: 20px;
	}

	.editor-code {
		width: calc(100% - 20px);
		padding-right: 10px;
		padding-left: 10px;
		height: 100%;
		overflow-y: auto;
		/* white-space: pre-wrap; */
		white-space: nowrap;
	}

	.editor-code .line {
		display: block;
	}

	.editor-code .line .string {
		color: #d14;
	}

	.editor-code .line .operator {
		color: gold;
	}

	.editor-code .line .comment {
		color: #999;
		font-style: italic;
	}

	.editor-code .line .keyword {
		color: #0086b3;
		font-weight: bold;
	}
</style>

<div class="editor">
	<div class="editor-lines">
		<li>1</li>
		<li>2</li>
		<li>3</li>
		<li>3</li>
		<li>4</li>
		<li>5</li>
		<li>6</li>
	</div>
	<div contenteditable="true" class="editor-code"></div>
</div>

<script>
	const keywords = ['تمام'];
	const ops = ['\\+', '\\-', '\\:', '\\=', '\\.'];
	const commands = ['صفحه', 'قطعه', 'جعبه', 'پاراگراف'];
	const arguments = ['منبع', 'مقصد', 'محتوا'];

	const editor = document.querySelector('.editor');
	const editor_code = editor.querySelector('.editor-code');
	const editor_lines = editor.querySelector('.editor-lines');

	const handleBlur = () => {
		editor_code.querySelectorAll('.line').forEach(line => line.classList.remove('active'));
		editor_lines.querySelectorAll('li').forEach(li => li.classList.remove('active'));
	};

	const updateLineNumbers = () => {
		const selection = window.getSelection();
		const range = selection.getRangeAt(0);
		const activeLine = range.startContainer.closest('.line');

		editor_code.querySelectorAll('.line').forEach(line => line.classList.remove('active'));
		editor_lines.querySelectorAll('li').forEach(li => li.classList.remove('active'));

		if (activeLine) {
			activeLine.classList.add('active');

			const lineIndex = Array.from(editor_code.children).indexOf(activeLine);
			const lineNumber = editor_lines.children[lineIndex];
			if (lineNumber) {
				lineNumber.classList.add('active');
			}
		}

		const lines = editor_code.querySelectorAll('.line');
		editor_lines.innerHTML = '';

		lines.forEach((_, index) => {
			const lineItem = document.createElement('li');

			lineItem.textContent = index + 1;
			editor_lines.appendChild(lineItem);
		});
	};

	const getLeadingSpaces = (lineElement) => {
		const lineText = lineElement.textContent;
		const leadingSpaces = lineText.match(/^\s*/)[0].length;

		return leadingSpaces;
	};

	const handleKeyTab = (event) => {
		const selection = window.getSelection();
		const range = selection.getRangeAt(0);

		const tabNode = document.createTextNode('\u00a0\u00a0\u00a0\u00a0');

		range.insertNode(tabNode);

		range.setStartAfter(tabNode);
		range.setEndAfter(tabNode);

		selection.removeAllRanges();
		selection.addRange(range);
	};

	const scrollIntoViewIfNeeded = (element) => {
		const rect = element.getBoundingClientRect();
		const isVisible = (
			rect.top >= 0 &&
			rect.left >= 0 &&
			rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
			rect.right <= (window.innerWidth || document.documentElement.clientWidth)
		);

		if (!isVisible) {
			element.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });
		}
	};

	const handleKeyLine = (event) => {
		const selection = window.getSelection();
		const range = selection.getRangeAt(0);

		const newLine = document.createElement('div');
		newLine.classList.add('line');

		newLine.innerHTML = '<br>';
		// newLine.innerHTML = '&#8203;';

		const currentLine = range.startContainer.parentElement;

		if (currentLine) {
			if (currentLine.classList.contains('line')) {
				currentLine.parentElement.insertBefore(newLine, currentLine.nextSibling);
			}
			else {
				currentLine.appendChild(newLine);
			}

			console.log("newLine: ", newLine);

			scrollIntoViewIfNeeded(newLine);

			const newRange = document.createRange();
			// newRange.setStart(newLine, 1);
			// newRange.setEnd(newLine, 1);
			// or?
			newRange.setStart(newLine, 0);
			newRange.setEnd(newLine, 0);

			const newSelection = window.getSelection();
			newSelection.removeAllRanges();
			newSelection.addRange(newRange);
		}
	};

	const handleKey = (event) => {
		console.log(event.key);

		if (event.key === 'Enter') {
			event.preventDefault();

			handleKeyLine();

			updateLineNumbers();
		}
		else if (event.key === 'Tab') {
			event.preventDefault();

			handleKeyTab();

			// updateLineNumbers();
		}
	};

	const highlight = (code) => {
		code = code.replace(/(["'])(?:(?=(\\?))\2.)*?\1/g, '<span class=string>$&</span>');
		code = code.replace(/\/\/[^\n]*/g, '<span class=comment>$&</span>');
		code = code.replace(/\/\*[\s\S]*?\*\//g, '<span class=comment>$&</span>');

		const keywordReg = `\\b(${[...keywords, ...commands, ...arguments].join('|')})\\b`;
		const keywordRegex = new RegExp(keywordReg, 'g');
		console.log(keywordReg, keywordRegex);
		code = code.replace(keywordRegex, '<span class=keyword>$&</span>');

		const opsReg = `(${ops.join('|')})`;
		const opsRegex = new RegExp(opsReg, 'g');
		console.log(opsReg, opsRegex);
		code = code.replace(opsRegex, '<span class=operator>$&</span>');

		return code;
	};

	const splitLines = () => {
		console.log("splitLines");
		const lines = editor_code.querySelectorAll(".line");

		lines.forEach((line) => {
			let h = highlight(line.textContent);
			if (h == line.textContent) {
				line.innerHTML = h;
			}
		});

		updateLineNumbers();
	};

	const synchronizeScroll = () => {
		editor_lines.scrollTop = editor_code.scrollTop;
	};

	const handlePaste = (event) => {
		event.preventDefault();

		const text = (event.clipboardData || window.clipboardData).getData('text');

		document.execCommand('insertText', false, text);
	};

	const handleFocus = () => {
		updateLineNumbers();

		const selection = window.getSelection();
		const activeLine = selection.anchorNode.closest('.line');

		if (activeLine) {
			activeLine.classList.add('active');
		}
	};

	editor_code.addEventListener('paste', handlePaste);
	editor_code.addEventListener('scroll', synchronizeScroll);
	editor_code.addEventListener('focus', handleFocus);
	editor_code.addEventListener('blur', handleBlur);
	editor_code.addEventListener('keydown', handleKey);
	editor_code.addEventListener('input', splitLines);

	editor_code.innerHTML = '<div class="line"><br></div>';
	editor_code.focus();

	splitLines();
</script>